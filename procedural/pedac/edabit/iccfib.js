// The Fibonacci sequence, as you know, is generated by iterative addition of the sum of the last two elements of the sequence to the end of the sequence, starting with [0, 1].
// Fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …]
// The iccanobiF sequence (see Resources tab for more info) is generated in a similar way — except that the digits of the last two elements should first be reversed, then added together, then added to the sequence. Single-digit numbers are unaffected, so the first 8 elements are identical to the Fibonacci sequence:
// iccanobiF = [0, 1, 1, 2, 3, 5, 8, 13]
// The next element is the sum of the reverse of 8 (still 8), and the reverse of 13 — 31 (8 + 31 = 39).
// iccanobiF = [0, 1, 1, 2, 3, 5, 8, 13, 39]
// iccanobiF = [0, 1, 1, 2, 3, 5, 8, 13, 39, 124]
// Create a function that takes a number n and returns the difference between the nth iccanobiF number and the nth Fibonacci number.

// Problem
//  Given a number, n, return the difference between the nth fibonacci number and the nth icc number
//  icc rules
//    The icc pattern starts with the same two elements as fib [0, 1]
//    The next icc number is made from reversing the last digit and adding it to the second to last digit
//    The first n <= 8 returns a value of 0, as the first 8 numbers of fib and icc are equal
//  special rules
//    can the input be negative? what should anything be returned for this situation? 
//    will we always receive a number
//    what will the largest input be that the function needs to handle? 

// Examples/tests
// iccMinusFib(8) // 0 
// iccMinusFib(9) // 18 /// fib(9) -- [0, 1, 1, 2, 3, 5, 8, 13, 21] icc(9) -- [0, 1, 1, 2, 3, 5, 8, 13, 39] 39 - 21 = 18
// iccMinusFib(10) // 72 /// fib(10) -- [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] icc(10) -- [0, 1, 1, 2, 3, 5, 8, 13, 39, 106]

// Data Structures
//  input: 1 number
//  output: 1 number
//  intermediate: array (use to generate and hold fib and icc sequences)

// High level 
//  create a function to generate the first n numbers of the fib sequence, return the nth number
//  create a function to generate the first n numbers of the icc sequence, return the nth number
//  subtract icc - fib

// Algorithm
//  return 0 if n is <= 8 
//  init start at [0, 1]
//  pass start and n to fib and icc
//    save the return values to variables
//    subtract icc - fib

//    Fib
//      while seq.length is less than n, 
//        push the return value of adding seq[seq.length - 1] + seq[seq.length - 2]
//      return seq[seq.length - 1]

//    Icc
//      while seq.length is less than n, 
//        grab the final number in seq, coerce to string, reverse the string, coerce to number, save to        variable flipped
//        push the return value of adding seq[seq.length - 1] + flipped
//      return seq[seq.length - 1]

function fib(n) {
  let seq = [0, 1];
  while (seq.length < n) {
    seq.push(seq[seq.length - 1] + seq[seq.length - 2]);
  }
  return seq[seq.length - 1];
}

function flipNum(num) {
  if (String(num).length === 1) return num;
  return Number([...String(num)].reverse().join(''));
}

function icc(n) {
  let seq = [0, 1];
  while (seq.length < n) {
    let flipped = flipNum(seq[seq.length - 1]);
    seq.push(flipped + seq[seq.length - 2]);
  }
  return seq[seq.length - 1];
}

function iccMinusFib(n) {
  if (n < 9) return 0;
  let iccN = icc(n);
  let fibN = fib(n);
  return iccN - fibN;
}

console.log(iccMinusFib(8)); // 0
console.log(iccMinusFib(9)); // 18 /// fib(9) -- [0, 1, 1, 2, 3, 5, 8, 13, 21] icc(9) -- [0, 1, 1, 2, 3, 5, 8, 13, 39] 39 - 21 = 18
console.log(iccMinusFib(10)); // 72 /// fib(10) -- [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] icc(10) -- [0, 1, 1, 2, 3, 5, 8, 13, 39, 106]